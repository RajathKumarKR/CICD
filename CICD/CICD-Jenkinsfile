node {
 try{
 def server = Artifactory.server 'Artifactory'
 def rtMaven = Artifactory.newMavenBuild()
 def buildInfo
 def dockerImagesTagVersion = 'NaV'  //This will ensure that docker images tag should have 1-1 relation ship with project version
 projectToBuild = 'CICD'
 def gitUrl = 'https://github.com/RajathKumarKR/CICD.git'
 def gitCredentials = 'RajathKumarKR'
 
 stage('------- Checkout --------') {
  // Checkout only pre-registration Module
   checkout([$class: 'GitSCM',
    branches: [
     [name: 'master']
    ],
    userRemoteConfigs: [
     [url: gitUrl, credentialsId:gitCredentials ]
    ]
   ])
 }

 stage('--------- Artifactory configuration ----------------') {
  rtMaven.tool = 'M2_HOME' // Tool name from Jenkins configuration
  rtMaven.deployer releaseRepo: 'libs-release-local', snapshotRepo: 'libs-snapshot-local', server: server
 // rtMaven.resolver releaseRepo: 'libs-release', snapshotRepo: 'libs-snapshot', server: server
  buildInfo = Artifactory.newBuildInfo()
  buildInfo.env.capture = true
 }

stage ('---------- build ---------------') {
         
	// for building java projects
        rtMaven.run pom: projectToBuild + '/pom.xml', goals: 'clean install', buildInfo: buildInfo
 }

 stage('---------- SonarQube Analysis --------------') {
  def mvnHome = tool name: 'M2_HOME', type: 'maven'
  withSonarQubeEnv('SonarQube') {
   sh "${mvnHome}/bin/mvn -f '$projectToBuild/' sonar:sonar"
  }
 }
 
 stage('----------- Publish build info -------------') {
  /*
  Publishing build info to Artifcatory (JFrog)
  */
  server.publishBuildInfo buildInfo
 }
 
 stage('------ Docker Images : Push & Cleanup -------') {
  /*
   Building Docker images of the services which have to be run inside a Docker Container and pushing the
   images to Docker Registry.
   This stage will build either all the Services (modules) present or only modules that have been changed
   since last build according to the build parameter provided.
  */

	/*
	finding parent pom version to create Docker tags
	*/
   pomFile = readMavenPom file: projectToBuild+'/pom.xml'
   dockerImagesTagVersion = pomFile.version
   echo dockerImagesTagVersion
 
	  
   /*
     Checking if there is any Dockerfile present to build, if not, returning from this stage
   */
   sh "find . -name 'Dockerfile'> testdirectoryDockerFiles"
   testlocationOfDockerFiles = readFile("testdirectoryDockerFiles").split("\\r?\\n");
   sh "rm -f testdirectoryDockerFiles"
   if (testlocationOfDockerFiles[0].equals("")) {
      echo "tested:::: no docker files present, returning"
      return;
     }
   /*
   Finding location of all the Dockerfiles present in module
   */
   sh "dirname `find . -name 'Dockerfile'`> directoryDockerFiles"
   locationOfDockerFiles = readFile("directoryDockerFiles").split("\\r?\\n");
   sh "rm -f directoryDockerFiles"
   /*
   If build paramerter is passed as Build All (All submodules have to be built)
   */
   if ("${env.BUIILD_OPTION}" == "Build All") {
    echo "BUILD_OPTION is set to Build All."
    echo "Building all submodules."
    for (int i = 0; i < locationOfDockerFiles.size(); i++) {
     if (locationOfDockerFiles[i].equals("")) {
      break;
     }
     def currentModule = locationOfDockerFiles[i]
     /*
     Getting name of the module to be built
     */
     sh "basename $currentModule > moduleName"
     moduleName = readFile('moduleName').trim()
     sh "rm -f moduleName"
     /*
     Getting path of the module to be built
     */
     modulePath = locationOfDockerFiles[i].substring(2);
     updatedServices.add(moduleName)
     updatedDockerImages.add(registryName + '/' + moduleName + ":$dockerImagesTagVersion.$BUILD_NUMBER")
     /*
     Updating containersToRun List
     */
     containersToRun = containersToRun + " " + registryName + '/' + moduleName
     /*
     Updating containersName List
     */
     containersNames = containersNames + " " + moduleName
     echo moduleName + " will be built"
     /*
     Pushing the module image with tag as version.buildnumber and tag as latest to docker registry
     */
     docker.withRegistry(registryUrl, registryCredentials) {
      def buildName = moduleName + ":$dockerImagesTagVersion.$BUILD_NUMBER"
      newApp = docker.build(buildName, '-f ' + currentModule + "/Dockerfile" + ' ' + modulePath)
      newApp.push()
      newApp.push 'latest'
     }
     /*
     Removing local images
     */
     sh "docker rmi $moduleName:$dockerImagesTagVersion.$BUILD_NUMBER"
     sh "docker rmi $registryName/$moduleName:$dockerImagesTagVersion.$BUILD_NUMBER"
     sh "docker rmi $registryName/$moduleName"
    }
   } 
   else {
    /*
     If build paramerter is passed as Build Changes (Only changed submodules have to be built)
    */   
    echo "BUILD_OPTION is set to Build Changed."
    echo "Building only changed submodules."
    changedModulesLocation = getChangedModulesPaths();
    for (int i = 0; i < changedModulesLocation.size(); i++) {
     def currentModule = changedModulesLocation[i]
     /*
     Getting name of the module to be built
     */
     sh "basename $currentModule > moduleName"
     moduleName = readFile('moduleName').trim()
     sh "rm -f moduleName"
     /*
     Getting path of the module to be built
     */
     modulePath = changedModulesLocation[i].substring(2);
     updatedServices.add(moduleName)
     updatedDockerImages.add(registryName + '/' + moduleName + ":$dockerImagesTagVersion.$BUILD_NUMBER")
     /*
     Updating containersToRun List
     */
     containersToRun = containersToRun + " " + registryName + '/' + moduleName
     /*
     Updating containersName List
     */
     containersNames = containersNames + " " + moduleName
     echo moduleName + " will be built"
     /*
     Pushing the module image with tag as version.buildnumber and tag as latest to docker registry
     */
     docker.withRegistry(registryUrl, registryCredentials) {
      def buildName = moduleName + ":$dockerImagesTagVersion.$BUILD_NUMBER"
      newApp = docker.build(buildName, '-f ' + currentModule + "/Dockerfile" + ' ' + modulePath)
      newApp.push()
      newApp.push 'latest'
     }
     /*
     Removing local images
     */
     sh "docker rmi $moduleName:$dockerImagesTagVersion.$BUILD_NUMBER"
     sh "docker rmi $registryName/$moduleName:$dockerImagesTagVersion.$BUILD_NUMBER"
     sh "docker rmi $registryName/$moduleName"
    }
   }

    /*
     Removing all untagged images
     */
    sh "docker rmi \$(docker images | awk '/<none>/ {print \$3}') || true"


 }
    
	}
 // Catching the exception for triggering email
  catch (exception) {
        print exception
		// If the job was aborted by any user
        if (exception instanceof InterruptedException) {
           currentBuild.result = "ABORTED"
        }
		// If the job failed due to some error
        else{
            currentBuild.result = "FAILURE"
        }
        
        throw exception //rethrow exception to prevent the build from proceeding
        }
  finally{
		if(currentBuild.result == "FAILURE"){
		// sending email to kernel recipients
	}
	}
}

