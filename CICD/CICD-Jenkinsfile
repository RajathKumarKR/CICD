node {
 try{
 def server = Artifactory.server 'Artifactory'
 def rtMaven = Artifactory.newMavenBuild()
 def buildInfo
 def branch = params.BRANCH_NAME
 def dockerImagesTagVersion = 'NaV'  //This will ensure that docker images tag should have 1-1 relation ship with project version
 projectToBuild = 'CICD'
 def gitUrl = params.GIT_URL
 def gitCredentials = params.GIT_CREDENTIALS
 
 stage('------- Checkout --------') {
  // Checkout only pre-registration Module
  dir(branch) {
   checkout([$class: 'GitSCM',
    branches: [
     [name: branch]
    ],
    userRemoteConfigs: [
     [url: gitUrl, credentialsId:gitCredentials ]
    ],
    extensions: [

     [$class: 'PathRestriction', excludedRegions: '', includedRegions: projectToBuild + '/.*'],
     //[$class: 'CloneOption', noTags: false, reference: '', shallow: true, timeout: 120, depth: 1, refspec:"+refs/heads/"+branch+":refs/remotes/origin/"+branch],
     [$class: 'SparseCheckoutPaths', sparseCheckoutPaths: [
      [$class: 'SparseCheckoutPath', path: '/' + projectToBuild + '/']
     ]]

    ],
   ])
  }
 }

 stage('--------- Artifactory configuration ----------------') {
  rtMaven.tool = 'M2_HOME' // Tool name from Jenkins configuration
  rtMaven.deployer releaseRepo: 'libs-release-local', snapshotRepo: 'libs-snapshot-local', server: server
  rtMaven.resolver releaseRepo: 'libs-release', snapshotRepo: 'libs-snapshot', server: server
  buildInfo = Artifactory.newBuildInfo()
  buildInfo.env.capture = true
 }

stage ('---------- build ---------------') {
         
	// for building java projects
        rtMaven.run pom: branch + '/' + projectToBuild + '/pom.xml', goals: 'clean install', buildInfo: buildInfo
 }

 stage('---------- SonarQube Analysis --------------') {
  def mvnHome = tool name: 'M2_HOME', type: 'maven'
  withSonarQubeEnv('sonar') {
   sh "${mvnHome}/bin/mvn -f '$branch/$projectToBuild/' sonar:sonar"
  }
 }
 
 stage('----------- Publish build info -------------') {
  /*
  Publishing build info to Artifcatory (JFrog)
  */
  server.publishBuildInfo buildInfo
 }
    
	}
 // Catching the exception for triggering email
  catch (exception) {
        print exception
		// If the job was aborted by any user
        if (exception instanceof InterruptedException) {
           currentBuild.result = "ABORTED"
        }
		// If the job failed due to some error
        else{
            currentBuild.result = "FAILURE"
        }
        
        throw exception //rethrow exception to prevent the build from proceeding
        }
  finally{
		if(currentBuild.result == "FAILURE"){
		// sending email to kernel recipients
	}
	}
}

@NonCPS
def getChangedModulesPaths() {
 Set modifiedModulePaths = [] as TreeSet

 /*
 ChangeSets until last build
 */
 def changeLogSets = currentBuild.changeSets

 /*
 A treeSet to store paths of all the files that have been changed until last build
 */
 Set affectedPaths = [] as TreeSet
 for (int i = 0; i < changeLogSets.size(); i++) {
  def entries = changeLogSets[i].items 
  for (int j = 0; j < entries.length; j++) {
   def entry = entries[j]
   echo "${entry.commitId} by ${entry.author} on ${new Date(entry.timestamp)}: ${entry.msg}"
   affectedPaths.addAll(entry.affectedPaths);
   }
  }
  /*
  Filtering all the modules from affected path that do not belong to project to build
  */
  echo "affected paths are :" + affectedPaths
  affectedPaths.retainAll{it.startsWith(projectToBuild)}
  echo "affected paths after retaining only kernel modules are --------:" + affectedPaths
for (int i = 0; i < locationOfDockerFiles.size(); i++) {
        /*
        If there is no Dockerfile present in the Services
        */
        if(locationOfDockerFiles[i].equals("")){
        	break;
        }
	/*
        Checking if the paths affected belong to modules that have to be deployed
        */
		if(affectedPaths.any{it.startsWith(locationOfDockerFiles[i].substring(2))}){
			modifiedModulePaths.add(locationOfDockerFiles[i])
            /*
            Removing affected paths that belong to same module (Because we have already taken
            into consideration this module)
            */
			affectedPaths.removeAll{it.startsWith(locationOfDockerFiles[i].substring(2))}
		}
		
		
	
  }
	echo "paths of modules to be built ::::::::::::>" + modifiedModulePaths
 	return modifiedModulePaths
}

